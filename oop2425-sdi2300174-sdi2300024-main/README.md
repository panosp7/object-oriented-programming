- ΤΡΟΠΟΣ ΕΚΤΕΛΕΣΗΣ:
    Η εργασία διαμορφώθηκε σε modules κι ο τρόπος εκτέλεσης του προγράμματος είναι: Για τη μετατροπή των αρχείων .cpp σε αντικειμενικά (.ο) κι τη μεταγλώττιση του προγράμματος τρέχουμε την εντολή make. Έπειτα, το εκτελέσιμο αρχείο που παράγεται με όνομα oop24 εκτελίται με τον ακόλουθο τρόπο ./oop24 files/categories.txt files/products.txt files/users.txt

- ΕΞΗΓΗΣΗ USERS ADT:
    Για την αποθήκευση των χρηστών χρησιμοποιήσαμε ένα map, όπου map<string, User*> users. Το map αποθηκέυει δείκτες προς αντικείμενα τύπου User και τα αντικείμενα μπορεί να είναι είτε Admin είτε Customer. Μέσω του map, επιτρέπουμε την πρόσβαση στις μεθόδους των παράγωγων κλάσεων Admin, Customer, μέσω dynamic_cast. Κάθε κλειδί στο map είναι μοναδικό κι επομένως εξασφαλίζεται ότι κάθε username έιναι μοναδικό. Με το map λοιπόν, παρέχεται εύκολη διαχείριση των δεδομένων με πολυπλοκότηα O(logn).

- OUTPUT:
    Κάθε φορά που ο χρήστης πληκτρολογεί, εμφανίζουμε τι έγραψε διότι αν η εκτέλεση ΔΕΝ γίνει manually, αλλά με ορίσματα αρχείων όπως στα test δεν θα φαίνεται τι έχει πληκτρολογήσει ο χρήστης στο output. Για αυτό επειδή μας ενδιαφέρει το πρόγραμμά μας να είναι όσο πιο ευδιάκριτο και εύκολο γίνεται στην διόρθωση, εμφανίζουμε το input του χρήστη μετά από κάθε interaction με αυτόν. 

- Αρχείο Category.h:
    Στο αρχείο αυτό περιέχεται μία δομή που περιγράφει μία κατηγορία. Έχει ως μεταβλητές το όνομα της κατηγορίας κι έναν vector που περιέχει τις υποκατηγορίες κάθε κατηγορίας. Χρισμοποιούμε αυτή τη δομή για να διαχειριζόμαστε το αρχείο με τις κατηγορίες κι να βάζουμε ως τύπο στον vector το Category.

- Βοηθητικές συναρτήσεις:
    Φτιάξαμε κάποιες βοηθητικές συναρτήσεις που μας βοηθάνε στο πρόγραμμα (οι υλοποιήσεις βρίσκονται μέσα στα αρχεία Helper.h, Helper.cpp). 

    1) Έχουμε μία συνάρτηση trim η οποία αφαιρεί όλα τα πιθανά κενά από την αρχή κι το τέλος ενός string (το οποίο το παίρνει ως όρισμα). Εντοπίζουμε τον πρώτα χαρακτήρα που δεν είναι κενό διάστημα μέσω της find_first_not_of() κι τον τελευταίο μη-κενό χαρακτήρα μέσω της find_last_not_of(). Αν το string αποτελείται μόνο από κενά, τότε επιστρέφει κενό sting, αλλιώς επιστρέφει το substring μεταξύ των δύο αυτών χαρακτήρων. Είναι πολύ σημαντική συνάρτηση, διότι εξασφαλίζει ότι οι τιμές που διαβάζονται από τα αρχεία categories.txt, products.txt, users.txt ή οι τιμές που δίνει ο χρήστης δεν περιέχουν περιττά κενά. Για αυτό τη χρηισμοποιούμε σε όλα το πρόγραμμα κι αποτρέπονται πιθανά σφάλματα και αποτυχία των unit_tests.

    2) Έχουμε μία συνάρτηση save_products με ορίσματα ένα vector που περιέχει τα προιόντα του συστήματος και ένα αρχείο (το products.txt ως argv[2]), για να αποθηκεύουμε κάθε φορά αλλαγές που γίνονται στα προιόντα. Σε αυτή ανοίγουμε το αρχείο για να γράψουμε σε αυτό μέσω της ofstream και διατρέχουμε κάθε προιόν μέσα στο vector. Γράφουμε τα χαρακτηριστικά κάθε προιόντος ένα ένα δίνοντας προσοχή στην αποθήκευση της τιμής και της ποσότητας. Χρησιμοποιούμε μορφοποίηση για την τιμή (setprecision(2)) ώστε να αποθηκεύεται με ακρίβεια 2 δεκαδικών ψηφίων και ελέγχουμε αν η ποσότητα είναι ακέραιος αριθμός ή όχι και την αποθηκεύουμε αντίστοιχα. Τέλος κλείνουμε το αρχείο.

    3) Έχουμε μία συνάρτηση save_users με ορίσματα ένα map που περιέχει τoυς χρήστες του συστήματος και ένα αρχείο (το users.txt ως argv[3]), για να αποθηκεύουμε σε αυτό κάθε φορά τους χρήστες που κάνουν εγγραφή. Σε αυτή ανοίγουμε το αρχείο για να γράψουμε σε αυτό μέσω της ofstream και διατρέχουμε κάθε χρήστη μέσα στο map. Για κάθε χρήστη που κάνει εγγραφή αποθηκεύμε το όνομα, τον κωδικό του και αν είναι διαχειστής  (εκτυπώνουμε 1) ή πελάτης (εκτυπώνουμε 0). Τέλος κλείνουμε το αρχείο.

- ΚΛΑΣΗ Product:
    Καταρχάς, φτιάξαμε μία κλάση που θα αφορά κάθε προιόν (οι υλοποιήσεις βρίσκονται μέσα στα αρχεία Product.h, Product.cpp). Φτιάξαμε δύο constructors έναν default και έναν χωρίς. Έπειτα, φτιάξαμε setters κι getters συναρτήσεις για την πρόσβαση σε κάθε χαρακτηριστικό του προιόντος, δηλαδή τον τίτλο, την περιγραφή, την κατηγορία, την υποκατηγορία, την τιμή, τη μονάδα μέτρησης και τη διαθέσιμη του ποσότητα. Τέλος, φτιάξαμε και μία συνάρτηση που θα προβάλλει τα χαρακτηριστικά κάθε προιόντος με τον τρόπο που παρουσιάζονται στα δοσμένα παραδείγματα. Η κλάση αυτή είναι πολύ σημαντική, διότι χρησιμοποιείται παντού για τη διαχείριση των προιόντων.

- ΚΛΑΣΗ User:
    Φτιάξαμε την βασική κλάση User που αντιπροσωπεύει τους χρήστες του προγράμματος (οι υλοποιήσεις βρίσκονται μέσα στα αρχεία User.h, User.cpp). Είναι και αυτή μία σημαντική κλάση διότι εισάγει βασικά χαρακτηριστικά των χρηστών, δηλαδή όνομα, κωδικός και αν είναι διαχειριστές ή πελάτες. Έχουμε τον constuctor της κλάσης που παίρνει τις τρεις μεταβλητές-μέλη που αναφέρθηκαν προηγουμένως ως ορίσμτα και τις αρχικοποιεί. Επίσης έχουμε τρεις getters συναρτήσεις για την πρόσβαση στις τρεις αυτές μεταβλητές. Τέλος, έχουμε και μία συνάρτηση check_user που ελέγχει αν υπάρχει ίδιος χρήστης στο πρόγραμμα.

- ΚΛΑΣΗ Admin:
    Φτιάξαμε την παράγωγη κλάση Admin που κληρονομεί ως δημόσια τα χαρακτηριστικά της κλάσης User και αντιπροσωπεύει τους διαχειριστές του προγράμματος (οι υλοποιήσεις βρίσκονται μέσα στα αρχεία Admin.h, Admin.cpp). Με αυτή τη κλάση διαχειριζόμαστε τους διαχειριστές εύκολα και εκτελούμε κάθε λειτουργία τους. Καταρχάς, έχουμε τον constructor της κλάσης Admin, ο οποίος αρχικοποείται με βάση την βασικη κλάση User. Στη συνέχεια, έχουμε μία συνάρτηση που προβάλλει το μενού επιλογών του διαχειριστή.
    
    1) Για την πρώτη του επιλογή έχουμε μία συνάρτηση add_product που προσθέτει ένα προιόν στο σύστημα. Η συνάρτηση αυτή παίρνει ως ορίσματα ένα αρχείο (το products.txt ως argv[2]), ένα vector που περιέχει όλα τα προιόντα του συστήματος και ένα vector που περιέχει όλες τις κατηγορίες του συστήματος με τις υποκατηγορίες τους. Ζητείται βήμα προς βήμα κάθε χαρακτηριστικό του νέου προιόντος από τον χρήστη χρησιμοποιώντας συνεχώς τις συναρτήσεις ignore() κι getline() για να καθαρίζεται ο buffer κι να αποφεύγονται προβλήματα με τα getline. Επίσης διατρέχουμε τον vector για τις κατηγορίες ώστε να εκτυπώνονται στον χρήστη μόνο οι κατηγορίες που υπάρχουν και οι υποκατηγορίες της επιλεγμένης κατηγορίας. Τέλος, γίνεται αποθήκευση του νέου προιόντος στον vector για τα προιόντα και αποθήκευση των αλλαγών στο products.txt μέσω της συνάρτησης save_products().

    2) Για τη δεύτερη του επιλογή έχουμε μία συνάρτηση edit_product που επιτρέπει την επεξεργασία των χαρακτηριστικών του επιλεγμένου προιόντος. Η συνάρτηση αυτή παίρνει ως ορίσματα ένα αρχείο (το products.txt ως argv[2]) και ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να αλλάξει και το παίρνει ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Διατρέχουμε το vector για τα προιόντα ένα ένα, δίνουμε επιλογές στο χρήστη για να επιλέξει τι θέλει να αλλάξει στο προιόν που διάλεξε, ανανεώνουμε κάθε χαρακτηριστικό που επεξεργάστηκε ο χρήστης και στο τέλος αποθηκεύουμε τις αλλαγές στο products.txt. Αν το προιόν που επέλεξε ο χρήστης δεν υπάρχει εκτυπώνουμε ότι δεν βρέθηκε.

    3) Για την τρίτη του επιλογή έχουμε μία συνάρτηση remove_product που διαγράφει το επιλεγμένο προιόν από το σύστημα. Η συνάρτηση αυτή παίρνει ως ορίσματα ένα αρχείο (το products.txt ως argv[2]) και ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να διαγράψει και το παίρνει ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Διατρέχουμε το vector για τα προιόντα ένα ένα, το διαγράφουμε όταν το βρει μέσω της erase() κι αποθηκεύουμε τις αλλαγές στο products.txt. Αν το προιόν που επέλεξε ο χρήστης δεν βρεθεί εκυπώνουμε ότι δεν βρέθηκε.

    4) Για τη τέταρτη του επιλογή έχουμε μία συνάρτηση search_product που αναζητά το επιλεγμένο προιόν από το σύστημα. Η συνάρτηση αυτή παίρνει ως ορίσμα ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να ψάξει κι το δέχεται ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Διατρέχουμε το vector για τα προιόντα ένα ένα και όταν βρεθεί το προιόν αυτό το εκτυπώνουμε χρησιμοποιώντας τη show_product της κλάσης Product. Αν το προιόν που επέλεξε ο χρήστης δεν βρεθεί εκυπώνουμε ότι δεν βρέθηκε. 

    5) Για την πέμπτη του επιλογή έχουμε μία συνάρτηση show_unavailable_products που εκτυπώνει όσα προιόντα έχουν ξεμείνει από ποσότητα. Η συνάρτηση αυτή παίρνει ως όρισμα ένα vector που περιέχει όλα τα προίοντα του συστήματος. Η συγκεκριμένη συνάρτηση δεν υπάρχει στα δοσμένα παράδειγμα για τον τρόπο παρουσίασης κι υλοποίησης, οπότε διατρέχουμε το vector για τα προιόντα ένα ένα και εκτυπώνουμε όσα προιόντα έχουν μηδενική διαθέσιμη ποσότητα. Τα προίοντα τα χωρίζουμε με "----------------".

    6) Για την έκτη του επιλογή έχουμε μία συνάρτηση show_top5_products που εκτυπώνει τα 5 προιόντα με τη μεγαλύτερη ποσότητα που βρίσκονται στο σύστημα. Η συνάρτηση αυτή παίρνει ως όρισμα ένα vector που περιέχει όλα τα προίοντα του συστήματος. Η συγκεκριμένη συνάρτηση δεν υπάρχει στα δοσμένα παράδειγμα για τον τρόπο παρουσίασης και υλοποίησης, οπότε ταξινομούμε τα προιόντα με βάση την ποσότητα τους, χρησιμοποιώντας τη συνάρτηση sort() από τη βιβλιοθήκη <algorithm>, καθώς και τη συνάρτηση compare() που φτιάξαμε εμείς, η οποία επιστρέφει (true/false) για το αν το πρώτο προιόν είναι μεγαλύτερο από το δεύτερο και τέλος εκτυπώνουμε τα 5 μεγαλύτερα σε ποσότητα προιόντα. 

- ΚΛΑΣΗ Customer: 
    Φτιάξαμε την παράγωγη κλάση Customer που κληρονομεί ως δημόσια τα χαρακτηριστικά της κλάσης User και αντιπροσωπεύει τους πελάτες του προγράμματος (οι υλοποιήσεις βρίσκονται μέσα στα αρχεία Customer.h, Customer.cpp). Με αυτή τη κλάση διαχειριζόμαστε τους πελάτες εύκολα και εκτελούμε κάθε λειτουργία τους. Στις μεταβλητές-μέλη περιέχει ένα map που θα αποθηκεύει τα στοιχεία του καλαθιού (τίτλος και ποσότητα) και ένα vector που θα αποθηκεύει το ιστορικό παραγγελιών των χρηστών (έχει σαν τύπο το map του καλαθιού) Καταρχάς, έχουμε τον constructor της κλάσης Customer, ο οποίος αρχικοποείται με βάση την βασική κλάση User. Στη συνέχεια, έχουμε μία συνάρτηση που προβάλλει το μενού επιλογών του πελάτη.
    
    1) Για την πρώτη του επιλογή έχουμε μία συνάρτηση search_product που αναζητά προιόντα με διάφορους τρόπους. Η συνάρτηση αυτή παίρνει ως ορίσμα ένα vector που περιέχει όλα τα προιόντα του συστήματος. Αρχικά, δίνονται τρεις επιλογές στον πελάτη ανάλογα με το τι θέλει να αναζητήσει. Άμα επιλέξει 1 τότε ψάχνει για ένα συγκεκριμένο προιόν στο σύστημα το οποίο βάζει ο ίδιος ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά.Διατρέχουμε τον vector για τα προιόντα κι εκτυπώνουμε το προιόν άμα βρεθεί, αλλιώς εκτυπώνουμε ότι δεν βρέθηκε. Άμα επιλέξει 2 τότε ψάχνει τα προιόντα μιας συγκεκριμένης κατηγορίας. Βάζει λοιπόν ως είσοδο τη κατηγορία που θέλει κι την παίρνουμε χρησιμοποιώντας την trim(). Διατρέχουμε τον vector για τα προιόντα και εκτυπώνουμε όσα προιόντα ανήκουν στη κατηγορία αυτή, αλλιώς εκτυπώνουμε ότι δεν υπάρχουν προιόντα αυτής της κατηγορίας. Άμα επιλέξει 3 τότε ψάχνει να βρει κάποιο από τα διαθέσιμα προιόντα. Διατρέχουμε τον vector, εκτυπώνουμε όλα τα διαθέσιμα προιόντα δίπλα δίπλα και μετά ο πελάτης βάζει ως είσοδο ποιο από τα διαθέσιμο θέλει να βρει. Αν δεν υπάρχει το προιόν αυτό εκτυπώνουμε ότι δεν βρέθηκε.

    2) Για τη δεύτερη του επιλογή έχουμε μία συνάρτηση add_product_to_cart που προσθέτει ένα προιόν στο καλάθι. Η συνάρτηση αυτή παίρνει ως ορίσμα ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να προσθέσει και το παίρνει ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Διατρέχουμε το vector για τα προιόντα ένα ένα και άμα το βρει ζητάμε από τον χρήστη να βάλει κι την ποσότητα που θέλει, αλλιώς εκτυπώνουμε πως το προιόν δεν υπάρχει. Προσθέτουμε έπειτα το προιόν στο καλάθι μόνο αν υπάρχει διαθέσιμη ποσότητα.

    3) Για την τρίτη του επιλογή έχουμε μία συνάρτηση update_product_from_cart που επεξεργάζεται τη ποσότητα του επιλεγμένου προιόντος από το καλάθι. Η συνάρτηση αυτή παίρνει ως ορίσμα ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να αλλάξει την ποσότητά του και το παίρνει ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Διατρέχουμε το map για το καλάθι, λέμε στον χρήστη να δώσει την ποσότητα που θέλει να αλλάξει και άμα βάλει μηδενική ποσότητα, διαγράφουμε το προιόν από το καλάθι μέσω της erase(). Αν δεν βάλει μηδενική ποσότητα τότε διατρέχουμε τον vector για τα προιόντα και ανανεώνουμε την ποσότητα του προιόντος μόνο αν δεν υπεβαίνει την αρχική. Αν το προιόν που επέλεξε ο χρήστης δεν βρεθεί στο καλάθι εκυπώνουμε ότι δεν βρέθηκε.

    4) Για τη τέταρτη του επιλογή έχουμε μία συνάρτηση remove_product_from_cart που διαγράφει το επιλεγμένο προιόν από το καλάθι Η συνάρτηση αυτή παίρνει ως ορίσμα ένα vector που περιέχει όλα τα προιόντα του συστήματος. Ζητείται αρχικά το προιόν που θέλει ο χρήστης να διαγράψεει κι το δέχεται ως είσοδο χρησιμοποιώντας τη συνάρτηση trim() για να αποφεύγονται πιθανά σφάλματα απο κενά. Φτιάχνουμε έναν επαναλήπτη τύπου map που δείχνει στο επιλεγμένο προιόν κι άμα βρεθεί το διαγράφουμε μέσω της erase() .Αν το προιόν που επέλεξε ο χρήστης δεν βρεθεί στο καλάθι εκυπώνουμε ότι δεν βρέθηκε. 

    5) Για την πέμπτη του επιλογή έχουμε μία συνάρτηση complete_order που ολοκληρώνει μία παραγγελία. Η συνάρτηση αυτή παίρνει ως ορίσματα ένα αρχείο (το products.txt ως argv[2]) και ένα vector που περιέχει όλα τα προιόντα του συστήματος. Αρχικά ελέγχουμε αν το καλάθι είναι άδειο κι άμα είναι εκτυπώνουμε το αντίστοιχο μήνυμα. Έπειτα, ανοίγουμε το αρχείο για διάβασμα που βρίσκεται στον φάκελο order_history/ με όνομα username_history.txt, όπου username=όνομα συνδεδεμένου χρήστη. Διαβάζουμε γραμμή γραμμή το αρχείο αυτό κι μετά το κλείνουμε. Ανοίγουμε ξανά το αρχείο αυτό αλλά τώρα για να γράψουμε κι ξεκινάμε την εκτύπωση όλης της παραγγελιας με αριθμημένα καλάθια μέσα στο αρχείο. Διατρέχουμε το map για το καλάθι, διατρέχουμε κι το vector για τα προιόντα κι ανανεώνουμε τις ποσότητες των προιόντων που έγιναν παραγγελία. Εκτύπωνουμε ποσότητα, προιόν κι συνολικό κόστος όπως στα δοσμένα παραδείγματα, τα προσθέτουμε στο vector για το ιστορικό παραγγελιών και κλείνουμε το αρχείο. Στο τέλος αδειάζουμε το καλάθι και αποθηκεύουμε τις ανανεωμένες διαθέσιμες ποσότητες των προιόντως στο products.txt

    6) Για την έκτη του επιλογή έχουμε μία συνάρτηση view_order_history που εκτυπώνει το ιστορικό παραγγελιών του συνδεδεμένου χρήστη. Η συνάρτηση αυτή παίρνει ως όρισμα ένα vector που περιέχει όλα τα προίοντα του συστήματος. Ανοίγουμε το αρχείο για το ιστορικό παραγγελιών του χρήστη, το διαβάζουμε γραμμή προς γραμμή κι εκτυπώνουμε κάθε γραμμή του, όπως εκτυπώνονται στα δοσμένα παραδείγματα.

    7) Για την έβδομη του επιλογή έχουμε μία συνάρτηση view_cart που εκτυπώνει το καλάθι που επεξεργάζεται ο συνδεδεμένος χρήστης. Η συνάρτηση αυτή παίρνει ως όρισμα ένα vector που περιέχει όλα τα προίοντα του συστήματος. Τα εκτυπώνουμε με τον τρόπο που εκτυπώνονται στα δοσμένα παραδείγματα, διατρέχοντας το map για το καλάθι και τον vector για τα προιόντα.

- MAIN oop24:
    Στο αρχείο oop24.cpp περιέχεται η main η οποία είναι ο κορμός του eshop. Αρχικά κάνουμε include τα αρχεία και τις βιβλιοθήκες που χρειαζόμαστε, μέσα σε αυτές και η <memory> η οποία δεν έχει αναφερθεί παραπάνω διότι η μοναδική χρήση της είναι για το dynamic cast που κάνουμε. Δεχόμαστε τα 3 βασικα μας .txt αρχεία {categories products users} αρχικοποιώντας τα όπως έχει ζητηθεί. Διαβάζουμε το αρχείο category γραμμή γραμμή χωρίζοντας κατάλληλα τις κατηγορίες από τις υποκατηγορίες με τις βοηθητικές μας συναρτήσεις όπως προαναφέρθηκε για την αποφυγή προβλημάτων που δημιουργούνται με τα κενά. Στην συνέχεια κάνουμε το ίδιο και για το αρχείο products χωρίζοντας κατάλληλα τους τίτλους, τις περιγραφές, τις κατηγορίες, τις υποκατηγορίες, τις τιμές, τις μονάδες μετρήσεων και τις ποσότητες των προιόντων. Έπειτα επαναλαμβάνουμε και για το αρχείο users χωρίζοντας το όνομα, τον κωδικό και τον ρόλο του καθε χρήστη. Μόλις γίνουν τα παραπάνω, καλωσορίζουμε τον χρήστη στο eshop μας και τον ρωτάμε τι είδους σύνδεση θέλει. Αν ο χρήστης έχει ήδη λογαριασμό και δεν επιθυμεί να δημιουργήσει καινούριο επιλέγει να συνδεθεί και βάζει τα στοιχεία του. Αν είναι διαχειριστής συνδέεται αυτόματα με τις λειτουργείες και τα δικαιώματα που του αντιστοιχούν, διαφορετικά αν είναι πελάτης συνδέεται αυτόματα με τις λειτουργείες και τα δικαιώματα που του αντιστοιχούν αναλόγως. Το πρώτο πράγμα που θα δουν οι χρήστες μόλις επιλεχθεί ο ρόλος τους είναι οι επιλογές εντολών που τους δίνονται. Αν στην προσπάθεια σύνδεσης ο κωδικός που δίνεται είναι λανθασμένος τότε εμφανίζεται κατάλληλο μήνυμα. Αν απο την άλλη ο χρήστης δεν έχει ξανασυνδεθεί ή επιθυμεί να φτιάξει έναν καινούριο λογαριασμό επιλέγει να εγγραφεί και βάζει τα στοιχεία του. Ο χρήστης επιλέγει αν θέλει να εγγραφεί ως διαχειριστής ή πελάτης και ελέγχεται αν το όνομα που επέλεξε υπάρχει ήδη, αν ναι τότε εμφανίζεται κατάλληλο μήνυμα, αλλιώς ξεκινάει την περιήγησή του στο eshop όπως ακριβώς θα έκανε και κάποιος που επέλεξε "σύνδεση". Το πρόγραμμα τελειώνει και ο χρήστης αποχαιρετάται οταν επιλεχθεί το Exit. Τέλος πριν κλείσει το πρόγραμμα γίνεται αποδέσμευση μνήμης.